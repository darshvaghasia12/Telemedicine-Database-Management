import { InjectionToken } from '@angular/core';
import { isPlatformServer } from '@angular/common';
import { Observable, queueScheduler as queue } from 'rxjs';
export const RealtimeDatabaseURL = new InjectionToken('angularfire2.realtimeDatabaseURL');
export const DATABASE_URL = RealtimeDatabaseURL;
export class FirebaseZoneScheduler {
    constructor(zone, platformId) {
        this.zone = zone;
        this.platformId = platformId;
    }
    schedule(...args) {
        return this.zone.runGuarded(function () { return queue.schedule.apply(queue, args); });
    }
    keepUnstableUntilFirst(obs$) {
        if (isPlatformServer(this.platformId)) {
            return new Observable(subscriber => {
                const noop = () => { };
                const task = Zone.current.scheduleMacroTask('firebaseZoneBlock', noop, {}, noop, noop);
                obs$.subscribe(next => {
                    if (task.state === 'scheduled') {
                        task.invoke();
                    }
                    ;
                    subscriber.next(next);
                }, error => {
                    if (task.state === 'scheduled') {
                        task.invoke();
                    }
                    subscriber.error(error);
                }, () => {
                    if (task.state === 'scheduled') {
                        task.invoke();
                    }
                    subscriber.complete();
                });
            });
        }
        else {
            return obs$;
        }
    }
    runOutsideAngular(obs$) {
        return new Observable(subscriber => {
            return this.zone.runOutsideAngular(() => {
                return obs$.subscribe(value => this.zone.run(() => subscriber.next(value)), error => this.zone.run(() => subscriber.error(error)), () => this.zone.run(() => subscriber.complete()));
            });
        });
    }
}
export const runOutsideAngular = (zone) => (obs$) => {
    return new Observable(subscriber => {
        return zone.runOutsideAngular(() => {
            runInZone(zone)(obs$).subscribe(subscriber);
        });
    });
};
export const runInZone = (zone) => (obs$) => {
    return new Observable(subscriber => {
        return obs$.subscribe(value => zone.run(() => subscriber.next(value)), error => zone.run(() => subscriber.error(error)), () => zone.run(() => subscriber.complete()));
    });
};
const noopFunctions = ['ngOnDestroy'];
export const ÉµlazySDKProxy = (klass, observable, zone) => {
    return new Proxy(klass, {
        get: (_, name) => zone.runOutsideAngular(() => {
            if (klass[name]) {
                return klass[name];
            }
            if (noopFunctions.includes(name)) {
                return () => { };
            }
            let promise = observable.toPromise().then(mod => {
                const ret = mod && mod[name];
                if (typeof ret == 'function') {
                    return ret.bind(mod);
                }
                else if (ret && ret.then) {
                    return ret.then((res) => zone.run(() => res));
                }
                else {
                    return zone.run(() => ret);
                }
            });
            return new Proxy(() => undefined, {
                get: (_, name) => promise[name],
                apply: (self, _, args) => promise.then(it => it && it(...args))
            });
        })
    });
};
//# sourceMappingURL=angularfire2.js.map